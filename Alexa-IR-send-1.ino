/************************************************************************
 *
 *** MAIN Sketch ***
 *
 * This version merges all the other sketches.
 * Provides the following functionality:
 * 1- Ability to set-up wifi credentials via a hotspot
 * 2- User programming of IR keys as follows:
 * 2.1- four IR keys to control the four relays (devise type 1 below)
 * 2.2- One IR key to reset the whole configuration
 * 2.2- One IR key to trun on/off tv (devise type 2 below)
 * 2.2- Two IR key to increase/decrease tv volume (devise type 3 below)
 * 3- Alexa control of the four relays (devise type 1 below)
 * 4- Alexa ability to turn on/off tv (devise type 2 below)
 * 5- Alexa ability to increase/decrease volume of tv (devise type 3 below)
 * It is planned to control four relays with either Alexa or an IR remote
 * control.
 * For IR it uses five keys. Key 5 is used to reset the values.
 * just presss key 5 four four times and it will reset the first three keys
 *
 ************************************************************************/
#include <Arduino.h>
#include "SPI.h"
#ifdef ESP32
#include "AsyncTCP.h"
#include "WiFi.h"
#include "IRremote.h"
#else // ESP8266
#include "ESPAsyncTCP.h"
#include "ESP8266WiFi.h"
#include "IRremoteESP8266.h"
#include "IRrecv.h"
#include "IRsend.h"
#include "IRutils.h"
#endif
#include "fauxmoESP.h"

#include "hotspot.h"
#include "ir.h"
#include "dbg.h"

/**********************************************************************
 *
 * Begin of settings
 *
 **********************************************************************/
// Pin assignments
// IR pins
#define RECV_PIN 14  // input  IR signal
#ifdef ESP32
// SEND_PIN assigned to 4 in IRremote library
#else // ESP8266
#define SEND_PIN 4  // output IR signal
#endif


// Relay pins
#define RELAY_A_PIN 2
#define RELAY_B_PIN 12
#define RELAY_C_PIN 13
#define RELAY_D_PIN 15

// Alexa device names (Names used by Alexa)
#define DEVICE_NAME_RELAY_A "Relay A"
#define DEVICE_NAME_RELAY_B "Relay B"
#define DEVICE_NAME_RELAY_C "Relay C"
#define DEVICE_NAME_RELAY_D "Relay D"
#define DEVICE_NAME_E       "TV"
#define DEVICE_NAME_F       "Volumen"

// IR send settings
#define INVERT     false
#define MODULATION true

// Max counts for reset
#define MAX_RESET_COUNT    3
#define FORCE_RESET_COUNT 10

// Others
#define SERIAL_BAUDRATE 115200


/**********************************************************************
 *
 * End of settings
 *
 **********************************************************************/
String wifi_SSID;
String wifi_Password;
////////////////////////////////////////////////////////////////////////
// Basic library classes:
IRrecv irRecv(RECV_PIN);
decode_results results;  // used to keep the IR read data

#ifdef ESP32
IRsend irSend;
#else // ESP8266
IRsend irSend(SEND_PIN, INVERT, MODULATION);
#endif

fauxmoESP fauxmo;

////////////////////////////////////////////////////////////////////////
// Variables to store the keys:
unsigned long myRelayA = 0;
unsigned long myRelayB = 0;
unsigned long myRelayC = 0;
unsigned long myRelayD = 0;

// Variables to store keys activated by Alexa
unsigned long myDeviceE    = 0;
unsigned long myDeviceF_On  = 0;
unsigned long myDeviceF_Off = 0;

// Reset variables
unsigned long myReset = 0;
int        countReset = 0;
unsigned long lastKey = 0;
int        countLastKey = 0;

// Variables to store on/off state
boolean onRelayA = false;
boolean onRelayB = false;
boolean onRelayC = false;
boolean onRelayD = false;

// IR message length in bits
unsigned int lengthBits = 32;
////////////////////////////////////////////////////////////////////////

/***********************************************************************
 * ADDING Devices:
 *****************
 * Note this code handles three type of devices:
 * 1- Relays -- controlled by IR remote and Alexa
 * 2- IR devices with a single key (like TV on/off) -- controlled by Alexa only
 * 3- IR devices with two keys (like TV volume) -- controlled by Alexa only
 *
 * Adding a device type 1 (relays controlled b y IR and Alexa)
 * Use relay A as an example.
 * Define similar to myRelayA, onRelayA, RELAY_A_PIN, and DEVICE_NAME_RELAY_A
 *
 * Adding a device type 2 (IR devices with a single key to be managed by Alexa)
 * Use device E as an example.
 * Define similar to myDeviceE, DEVICE_NAME_E
 *
 * Adding a device type 3 (IR devices with two function keys (up/down or on/off) to be managed by Alexa)
 * Use device F as an example.
 * Define similar to myDeviceF_On, myDeviceF_Off, DEVICE_NAME_F
 *
 **********************************************************************/

// Function is called when we receive a message from Alexa
// The information passed to this function was generated by Alexa
void AlexaOnSetState(unsigned char device_id, const char * device_name, bool state, unsigned char value)
{
    dbg.print("[MAIN] Device #%d (%s) state: %s value: %d\n", device_id, device_name, state ? "ON" : "OFF", value);

    if (strcmp(device_name, DEVICE_NAME_RELAY_A)==0)
    {
        digitalWrite(RELAY_A_PIN, state ? HIGH : LOW);
        onRelayA = state;
        countReset=0;
        return;
    }
    if (strcmp(device_name, DEVICE_NAME_RELAY_B)==0)
    {
        digitalWrite(RELAY_B_PIN, state ? HIGH : LOW);
        onRelayB = state;
        countReset=0;
        return;
    }
    if (strcmp(device_name, DEVICE_NAME_RELAY_C)==0)
    {
        digitalWrite(RELAY_C_PIN, state ? HIGH : LOW);
        onRelayC = state;
        countReset=0;
        return;
    }
    if (strcmp(device_name, DEVICE_NAME_RELAY_D)==0)
    {
        digitalWrite(RELAY_D_PIN, state ? HIGH : LOW);
        onRelayD = state;
        countReset=0;
        return;
    }
    if (strcmp(device_name, DEVICE_NAME_E)==0)
    {
        // for on/off switch we can safely ignore the state variable
        sendCode(myDeviceE, codeRepeat);
        return;
    }
    if (strcmp(device_name, DEVICE_NAME_F)==0)
    {
        sendCode(state ? myDeviceF_On : myDeviceF_Off, codeRepeat);
        return;
    }
}

void setKey(unsigned long keyValue, unsigned long &key, const char* pName)
{
    key = keyValue;
    dbg.print("+set %s: 0x%08X\n",pName, key);
    saveKeys();
}

void setMyValue(unsigned long keyValue) // Function to program the keys
{
    // This will program the keys:
    // The first time a key is pressed it will set a value, and from there on that key will correspond to that value
    // Relay keys:
    if(myRelayA == keyValue) return;
    if(myRelayB == keyValue) return;
    if(myRelayC == keyValue) return;
    if(myRelayD == keyValue) return;
    // Reset key
    if(myReset  == keyValue) return;
    // Device keys (keys used by Alexa to send signal to the devices)
    if(myDeviceE  == keyValue) return;
    if(myDeviceF_On  == keyValue) return;
    if(myDeviceF_Off  == keyValue) return;

    // Ignored keys
    if(0xFFFFFFFF == keyValue || 0xFF == keyValue || REPEAT == keyValue)
    {
        return;
    }

    // Now set the keys (only happen first time)
    ///////////////////////////////////////////////////////////////////////////////////////////
    //// NOTE: This set of if statements define the order in which the keys are programmed ////
    ///////////////////////////////////////////////////////////////////////////////////////////
    // first programm on/off key
    if(myDeviceE == 0)
    {
        setKey(keyValue, myDeviceE, "DeviceE");
        return;
    }
    // Second program the four relay keys
    if(myRelayA == 0)
    {
        setKey(keyValue, myRelayA, "RelayA");
        return;
    }
    if(myRelayB == 0)
    {
        setKey(keyValue, myRelayB, "RelayB");
        return;
    }
    if(myRelayC == 0)
    {
        setKey(keyValue, myRelayC, "RelayC");
        return;
    }
    if(myRelayD == 0)
    {
        setKey(keyValue, myRelayD, "RelayD");
        return;
    }
    // Now let program the reset key
    if(myReset  == 0)
    {
        setKey(keyValue, myReset, "Reset");
        return;
    }
    // Last let program the next device (couple of keys)
    if(myDeviceF_On == 0)
    {
        setKey(keyValue, myDeviceF_On,  "DeviceF_On");
        return;
    }
    if(myDeviceF_Off == 0)
    {
        setKey(keyValue, myDeviceF_Off, "DeviceF_Off");
        return;
    }
}

void doReset()
{
    dbg.print("***Reseting (%d) ***\n",countReset);
    myRelayA = myRelayB = myRelayC = myRelayD = 0;
    onRelayA = onRelayB = onRelayC = onRelayD = false;
    digitalWrite(RELAY_A_PIN, LOW);
    digitalWrite(RELAY_B_PIN, LOW);
    digitalWrite(RELAY_C_PIN, LOW);
    digitalWrite(RELAY_D_PIN, LOW);
    countReset = 0;
    // May want to reset other funtionality by uncommenting some of the following lines:
    //myReset = 0; // reset the reset key
    //myDeviceE = myDeviceF_On = myDeviceF_Off = 0; // reset device programming
    removeCredentials();
}

void useValue(unsigned long keyValue) // Function to turn on/off relays based on the keys
{
    if(0xFFFFFFFF == keyValue || 0xFF == keyValue || REPEAT == keyValue)
    {
        return;
    }

    if(myRelayA == keyValue)
    {
        digitalWrite(RELAY_A_PIN, onRelayA ? LOW : HIGH);
        onRelayA = !onRelayA;
        countReset=0;
        dbg.print("=> Received RelayA key\n");
        return;
    }
    if(myRelayB == keyValue)
    {
        digitalWrite(RELAY_B_PIN, onRelayB ? LOW : HIGH);
        onRelayB = !onRelayB;
        countReset=0;
        dbg.print("=> Received RelayB key\n");
        return;
    }
    if(myRelayC == keyValue)
    {
        digitalWrite(RELAY_C_PIN, onRelayC ? LOW : HIGH);
        onRelayC = !onRelayC;
        countReset=0;
        dbg.print("=> Received RelayC key\n");
        return;
    }
    if(myRelayD == keyValue)
    {
        digitalWrite(RELAY_D_PIN, onRelayD ? LOW : HIGH);
        onRelayD = !onRelayD;
        countReset=0;
        dbg.print("=> Received RelayD key\n");
        return;
    }
    if(myReset == keyValue)
    {
        dbg.print("=> Received reset key\n");
        if(countReset++ > MAX_RESET_COUNT)
            doReset();

        return;
    }
    else
        countReset=0;

    dbg.print("=> Received non-programmed key\n");
}

void wifiSetup() // Function used to initialize WiFi communication
{
    // Set WIFI module to STA mode
    WiFi.mode(WIFI_STA);

    // Connect
    dbg.print("[WIFI] Connecting to %s ", wifi_SSID);
    WiFi.begin(wifi_SSID.c_str(), wifi_Password.c_str());

    // Wait
    int count = 0;
    while (WiFi.status() != WL_CONNECTED)
    {
        dbg.print(".");
        delay(100);
        if(++count > 100)
        {
            dbg.print("\n");
            removeCredentials();
            return;
        }
    }
    dbg.print("\n");

    // Connected!
    dbg.print("[WIFI] STATION Mode, SSID: %s, IP address: %s\n", WiFi.SSID().c_str(), WiFi.localIP().toString().c_str());
}

void alexaSetup()
{
    fauxmo.createServer(true);
    fauxmo.setPort(80); // This is required for gen3 devices
    fauxmo.enable(true);
    // Add virtual devices
    fauxmo.addDevice(DEVICE_NAME_RELAY_A);
    fauxmo.addDevice(DEVICE_NAME_RELAY_B);
    fauxmo.addDevice(DEVICE_NAME_RELAY_C);
    fauxmo.addDevice(DEVICE_NAME_RELAY_D);
    fauxmo.addDevice(DEVICE_NAME_E);
    fauxmo.addDevice(DEVICE_NAME_F);

    fauxmo.onSetState(&AlexaOnSetState);
}


////////////////////////////////////////////////////////////////////////
// Main functions -- setup() and loop()
////////////////////////////////////////////////////////////////////////
void setup() // Initialize
{
    Serial.begin(SERIAL_BAUDRATE);
    dbg.print("--------------------\n\nSTART ");

    irRecv.enableIRIn(); // enable IR receive
#ifndef ESP32
    irSend.begin();      // enable IR transmiter
#endif

    // Assign the pin mode
    pinMode(RELAY_A_PIN, OUTPUT);
    pinMode(RELAY_B_PIN, OUTPUT);
    pinMode(RELAY_C_PIN, OUTPUT);
    pinMode(RELAY_D_PIN, OUTPUT);

    // Initial state is all relays off
    digitalWrite(RELAY_A_PIN, LOW);
    digitalWrite(RELAY_B_PIN, LOW);
    digitalWrite(RELAY_C_PIN, LOW);
    digitalWrite(RELAY_D_PIN, LOW);

    if(startFileSystem() && checkSavedCredentials())
    {
        restoreKeys();
        dbg.print("\nNORMAL MODE\n");
        wifiSetup(); // initialize the WiFi
        alexaSetup();
    }
    else
    {
        restoreKeys();
        dbg.print("\nHOTSPOT MODE\n");
        startHotspot();
    }
}

void loop() // Simplified main loop
{
    if(restartESP)
    {
        dbg.print("Restarting ESP\n");
        ESP.restart();
    }

    fauxmo.handle(); // First handle Alexa

    hotspotClient = hotspotServer.available();   // Listen for incoming hotspot clients
    if (hotspotClient) processHotspotRequest();

    if (irRecv.decode(&results)) // Second, deal with the IR remote
    {
        unsigned long keyValue = storeCode(&results);

        // Process lastKey (forced reset)
        if(0xFFFFFFFF != results.value && 0xFF != results.value) // ignore repeat
        {
            if(results.value == lastKey)
            {
                if(++countLastKey > FORCE_RESET_COUNT) 
                    doReset();
            }
            else
            {
                countLastKey = 0;
                lastKey = results.value;
            }
        }

        setMyValue(keyValue);
        useValue(keyValue);
        delay(10);
        irRecv.resume();
    }
}
